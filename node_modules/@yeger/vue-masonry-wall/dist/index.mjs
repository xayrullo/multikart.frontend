import { defineComponent as z, toRefs as L, ref as S, onMounted as N, onBeforeUnmount as U, watch as W, openBlock as m, createElementBlock as v, normalizeStyle as $, unref as i, Fragment as A, renderList as D, renderSlot as V, createTextVNode as j, toDisplayString as q, nextTick as G } from "vue";
const H = ["data-index"], J = /* @__PURE__ */ z({
  __name: "masonry-wall",
  props: {
    columnWidth: { default: 400 },
    items: {},
    gap: { default: 0 },
    rtl: { type: Boolean, default: !1 },
    ssrColumns: { default: 0 },
    scrollContainer: { default: null },
    minColumns: {},
    maxColumns: {},
    keyMapper: { type: Function, default: (o, c, _, r) => r }
  },
  emits: ["redraw", "redrawSkip"],
  setup(o, { emit: c }) {
    const _ = o, {
      columnWidth: r,
      items: u,
      gap: f,
      rtl: k,
      ssrColumns: g,
      scrollContainer: C,
      minColumns: y,
      maxColumns: w,
      keyMapper: E
    } = L(_), d = S([]), p = S();
    function x(t, e, n, l) {
      const a = B(n);
      return l + e + a <= t ? x(
        t,
        e,
        n + 1,
        l + e + a
      ) : n;
    }
    function B(t) {
      const e = Array.isArray(r.value) ? r.value : [r.value];
      return e[t % e.length];
    }
    function b() {
      const t = x(
        p.value.getBoundingClientRect().width,
        f.value,
        0,
        // Needs to be offset my negative gap to prevent gap counts being off by one
        -f.value
      ), e = Y(F(t));
      return e > 0 ? e : 1;
    }
    function F(t) {
      const e = w == null ? void 0 : w.value;
      return e && t > e ? e : t;
    }
    function Y(t) {
      const e = y == null ? void 0 : y.value;
      return e && t < e ? e : t;
    }
    function M(t) {
      return [...new Array(t)].map(() => []);
    }
    if (g.value > 0) {
      const t = M(g.value);
      u.value.forEach(
        (e, n) => t[n % g.value].push(n)
      ), d.value = t;
    }
    async function T(t) {
      if (t >= u.value.length)
        return;
      await G();
      const e = [...p.value.children];
      k.value && e.reverse();
      const n = e.reduce(
        (l, a) => a.getBoundingClientRect().height < l.getBoundingClientRect().height ? a : l
      );
      d.value[+n.dataset.index].push(t), await T(t + 1);
    }
    async function h(t = !1) {
      if (d.value.length === b() && !t) {
        c("redrawSkip");
        return;
      }
      d.value = M(b());
      const e = C == null ? void 0 : C.value, n = e ? e.scrollTop : window.scrollY;
      await T(0), e ? e.scrollBy({ top: n - e.scrollTop }) : window.scrollTo({ top: n }), c("redraw");
    }
    const s = typeof ResizeObserver > "u" ? void 0 : new ResizeObserver(() => h());
    return N(() => {
      h(), s == null || s.observe(p.value);
    }), U(() => s == null ? void 0 : s.unobserve(p.value)), W([u, k], () => h(!0)), W([r, f, y, w], () => h()), (t, e) => (m(), v("div", {
      ref_key: "wall",
      ref: p,
      class: "masonry-wall",
      style: $({ display: "flex", gap: `${i(f)}px` })
    }, [
      (m(!0), v(A, null, D(d.value, (n, l) => (m(), v("div", {
        key: l,
        class: "masonry-column",
        "data-index": l,
        style: $({
          display: "flex",
          "flex-basis": `${B(l)}px`,
          "flex-direction": "column",
          "flex-grow": 1,
          gap: `${i(f)}px`,
          height: ["-webkit-max-content", "-moz-max-content", "max-content"],
          "min-width": 0
        })
      }, [
        (m(!0), v(A, null, D(n, (a, R) => (m(), v("div", {
          key: i(E)(i(u)[a], l, R, a),
          class: "masonry-item"
        }, [
          V(t.$slots, "default", {
            item: i(u)[a],
            column: l,
            row: R,
            index: a
          }, () => [
            j(q(i(u)[a]), 1)
          ])
        ]))), 128))
      ], 12, H))), 128))
    ], 4));
  }
}), P = /* @__PURE__ */ (() => {
  const o = J;
  return o.install = (c) => {
    c.component("MasonryWall", o);
  }, o;
})();
export {
  P as default
};
